# Задание 5. Система отслеживания посылок

## Описание:
Разработать архитектуру системы, позволяющую пользователям отслеживать статус их посылок в режиме реального времени.

## Решение по System Design должно включать:

- Количество запросов в секунду (RPS)
- Расчет объема сохраняемых данных
- Расчет объема читаемых данных
- Схему компонентов
- Примерное перечисление ендпоинтов API с указанием базовых полей запроса и ответа

### Use Cases:
- Регистрация посылки
- Обновление статуса посылки
- Получение информации о статусе

### Нагрузка:
- DAU: 2 млн пользователей
- Среднее количество обновлений статуса в день: 10 млн
- Время хранения данных: 6 месяцев

### Out of Scope:
- Интеграция с физическим оборудованием

# Решение:

## Количество запросов в секунду (RPS)

1. **Обновление статуса:** Предположим, что большая часть обновлений происходит в течении 12 часов: 10 000 000 / (12 * 3600) ≈ 231.5 RPS 
2. **Получение информации о статусе:** Предположим, что каждый активный пользователь запрашивает статус посылки в среднем 2 раза в день: 2 000 000 * 2 = 4 000 000 запросов в день
    - **RPS для получения статуса:** 4 000 000 / 12 * 3600) ≈ 92.6 RPS 
3. **Регистрация посылок:** Предположим 10% от обновлений статуса в день: 10 000 000 * 0.1 = 1 000 000 регистраций в день
    - **RPS для регистрации:** 1 000 000 / (12 * 3600) ≈ 23.1 RPS
### ИТОГО:
**Общий средний RPS:** 231.5 + 92.6 + 23.1 ≈ **347.2 RPS** 

## Расчет объема сохраняемых данных

1. **Размер записи о посылке:** Предположим, что одна запись (включая ID посылки, ID пользователя, историю статусов, текущий статус) занимает около 1 KB
2. **Среднее количество посылок:** Предположим, что среднее количество посылок на пользователя: 3
3. **Объём данных:**
    - **Объём общей информации:** 2 000 000 * 3 * 1 KB ≈ 6 GB
    - **Объём обновления статуса:** 10 000 000 / 180 дней * 1 KB ≈ 55.6 MB
### ИТОГО:
**Общий объем сохраняемых данных за 6 месяцев:** 6 GB + 55.6 MB ≈ **6.055 GB**

## Расчет объема читаемых данных

1. **Получение информации о статусе:** Предположим, что каждый активный пользователь запрашивает статус посылки в среднем 2 раза в день: 2 000 000 * 2 = 4 000 000 запросов в день
2. **Размер чтения:** Предположим, что запрос на чтение статуса посылки возвращает около 1 KB данных 
### ИТОГО:
**Объем читаемых данных:** 4 000 000 запросов в день * 1 KB = **4 GB** в день

## Схема компонентов

<img width="800" alt="Схема" src="https://github.com/user-attachments/assets/6f5fe1d9-6407-4a6b-b206-0df7c56fc445" />

### Компоненты системы:
1. **Load Balancer (LB):**
    - Распределяет входящие запросы между экземплярами сервисов
    - Обеспечивает отказоустойчивость и масштабируемость
2. **API Gateway (AG):**
   - Единая точка входа для всех запросов от пользователей и служб доставки
   -  Осуществляет аутентификацию, авторизацию и маршрутизацию запросов
3. **Database (PostgreSQL) (DB):**
    - Основное хранилище для всей информации о посылках, статусах
    - Используется PostgreSQL как надежная и масштабируемая реляционная база данных
4. **Message Queue (Kafka) (MQ):**
    - Используется для асинхронной отправки уведомлений об изменениях статуса
    - Развязывает Status Service и Notification Service
5. **Tracking Service (TS):**
    - Сервис для управления информацией о посылках
    - Предоставляет API для регистрации посылки
6. **Status Service (SS):**
    - Сервис для управления статусами посылок
    - Предоставляет API для обновления статусов и получения информации
7. **Notification Service (NS):**
    - Сервис для отправки уведомлений (об обновлении статуса, изменении местоположения и т. д.)
    - Использует Message Queue для асинхронной отправки
8. **Cache (Redis) (CACHE):**
    - Кэш для хранения часто запрашиваемых статусов посылок
    - Ускоряет отклик системы

## Примерное перечисление ендпоинтов API с указанием базовых полей запроса и ответа

### 1. Регистрация посылки:
1. Endpoint: POST /parcels
2. Request Body (JSON):

```json
{
    "userId": "user123",
    "sender": "Имя отправителя",
    "recipient": "Имя получателя" ,
    "destination": "Адрес назначения"
}
```

3. Response (JSON):

```json
{
  "parcelId": "parcel456",
   "status": "registered"
}
```

### 2. Обновление статуса посылки:
1. Endpoint: POST /parcels/{parcelId}/status
2. Request Body (JSON):

```json 
{
    "status": "inTransit",
    "location": "Склад 123"
}
```

3. Response (JSON):

```json
{
     "parcelId": "parcel456",
     "status": "inTransit"
 }
 ```

### 3. Получение информации о статусе посылки:
1. Endpoint: GET /parcels/{parcelId}
2. Request Body (JSON):

```json
{
    "parcelId": "parcel456"
}
```

3. Response (JSON):

```json
{
    "parcelId": "parcel456",
    "status": "inTransit",
    "history": [
        {
          "status": "registered",
          "location": null,
          "timestamp": "2024-10-27T10:00:00Z"
        },
        {
            "status": "inTransit",
            "location": "Склад 123",
            "timestamp": "2024-10-27T12:00:00Z"
        }
    ],
    "sender": "Имя отправителя",
    "recipient": "Имя получателя"
}
```












